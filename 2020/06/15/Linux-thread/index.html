<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux thread | szfck</title><meta name="description" content="task_struct &#x2F; mm_struct一个进程的虚拟地址空间主要由两个数据结构来描述。一个是最高层次的：mm_struct（定义在mm_types.h中），一个是较高层次的：vm_area_structs。最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_truct描述了虚拟地址空间的一个区间（简称虚拟区或线性区）。每个进程只有一个mm_str"><meta name="keywords" content="Linux"><meta name="author" content="Kai Chen"><meta name="copyright" content="Kai Chen"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux thread"><meta name="twitter:description" content="task_struct &#x2F; mm_struct一个进程的虚拟地址空间主要由两个数据结构来描述。一个是最高层次的：mm_struct（定义在mm_types.h中），一个是较高层次的：vm_area_structs。最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_truct描述了虚拟地址空间的一个区间（简称虚拟区或线性区）。每个进程只有一个mm_str"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Linux thread"><meta property="og:url" content="https://szfck.github.io/2020/06/15/Linux-thread/"><meta property="og:site_name" content="szfck"><meta property="og:description" content="task_struct &#x2F; mm_struct一个进程的虚拟地址空间主要由两个数据结构来描述。一个是最高层次的：mm_struct（定义在mm_types.h中），一个是较高层次的：vm_area_structs。最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_truct描述了虚拟地址空间的一个区间（简称虚拟区或线性区）。每个进程只有一个mm_str"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-06-15T04:47:50.000Z"><meta property="article:modified_time" content="2020-06-15T08:02:29.609Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://szfck.github.io/2020/06/15/Linux-thread/"><link rel="prev" title="Volatile" href="https://szfck.github.io/2020/06/15/Volatile/"><link rel="next" title="xss reflect" href="https://szfck.github.io/2020/05/30/xss-reflect/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#task-struct-mm-struct"><span class="toc-number">1.</span> <span class="toc-text">task_struct &#x2F; mm_struct</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#do-fork"><span class="toc-number">2.</span> <span class="toc-text">do_fork</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#“one-to-one”-model"><span class="toc-number">3.</span> <span class="toc-text">“one-to-one” model</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程绑定CPU"><span class="toc-number">4.</span> <span class="toc-text">进程绑定CPU</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">5.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">szfck</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Linux thread</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-06-15 12:47:50"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-06-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-06-15 16:02:29"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-15</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="task-struct-mm-struct"><a href="#task-struct-mm-struct" class="headerlink" title="task_struct / mm_struct"></a>task_struct / mm_struct</h1><p>一个进程的虚拟地址空间主要由两个数据结构来描述。一个是最高层次的：mm_struct（定义在mm_types.h中），一个是较高层次的：vm_area_structs。最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_truct描述了虚拟地址空间的一个区间（简称虚拟区或线性区）。每个进程只有一个mm_struct结构，在每个进程的task_struct结构中，有一个指向该进程的结构。可以说，mm_struct结构是对整个用户空间（注意，是用户空间）的描述。</p>
<p><img src="/images/linux_thread/pcb.png" alt=""></p>
<p><img src="/images/linux_thread/mm.png" alt=""></p>
<h1 id="do-fork"><a href="#do-fork" class="headerlink" title="do_fork"></a>do_fork</h1><pre><code>do_fork -&gt; copy_process -&gt; copy_mm -&gt; dup_mmap</code></pre><p>copy_process函数中首先调用dup_task_struct()函数为子进程创建task_struct结构体等信息，然后根据clone_flags集合中的标志值，设置共享或者复制父进程打开的文件、文件系统信息、信号处理函数、进程地址空间、命名空间等资源，其中copy_mm函数实现父进程地址空间的拷贝，也就是fork创建子进程时的写时复制机制的核心处了，接下来看看这个函数的实现。</p>
<p>copy_mm()中检查clone_flags中是否有CLONE_VM标志，</p>
<ul>
<li>若有，两个进程之间共享VM，即就是创建轻量级进程(线程)，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 当创建一个新的进程时，内核调用copy_mm函数，</span><br><span class="line"> * 这个函数通过建立新进程的所有页表和内存描述符来创建进程的地址空间。</span><br><span class="line"> * 通常，每个进程都有自己的地址空间，但是轻量级进程共享同一地址空间，即允许它们对同一组页进行寻址。</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int copy_mm(unsigned long clone_flags, struct task_struct * tsk) </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 指定了CLONE_VM标志，表示创建线程。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 新线程共享父进程的地址空间，所以需要将mm_users加一。</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">		mm &#x3D; oldmm;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 没有CLONE_VM标志，就必须创建一个新的地址空间。</span><br><span class="line">	 * 必须要有地址空间，即使此时并没有分配内存。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	retval &#x3D; -ENOMEM;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 分配一个新的内存描述符。把它的地址存放在新进程的mm中。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	mm &#x3D; allocate_mm();</span><br><span class="line">	...</span><br><span class="line">	&#x2F;* Copy the current MM stuff.. *&#x2F;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 并从当前进程复制mm的内容。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	memcpy(mm, oldmm, sizeof(*mm));</span><br><span class="line">	...</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * dup_mmap不但复制了线程区和页表，也设置了mm的一些属性.</span><br><span class="line">	 * 它也会改变父进程的私有，可写的页为只读的，以使写时复制机制生效。</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	retval &#x3D; dup_mmap(mm, oldmm);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>否则，就是fork创建进程，从而调用dup_mm()函数为子进程分配一个新的mm_struct结构体。</p>
<ul>
<li>使用dup_mmap()函数为子进程拷贝父进程地址空间，其中调用copy_page_range()函数进行页表的拷贝，由于linux中采用四级分页机制，分别是pgd、pud、pmd、pte，因而依次对其进行拷贝，最终在拷贝pte的函数copy_pte_range中调用copy_one_page函数实现真正的写时复制。</li>
</ul>
</li>
</ul>
<p>在该函数中判断页是否支持写时复制，若支持就给其添加写保护，在写操作发生时，发生写保护错误，从而为子进程新分配一块内存。</p>
<p><img src="/images/linux_thread/4page.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static inline void</span><br><span class="line">copy_one_pte(struct mm_struct *dst_mm,  struct mm_struct *src_mm,</span><br><span class="line">		pte_t *dst_pte, pte_t *src_pte, unsigned long vm_flags,</span><br><span class="line">		unsigned long addr)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If it&#39;s a COW mapping, write protect it both</span><br><span class="line">	 * in the parent and the child</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if ((vm_flags &amp; (VM_SHARED | VM_MAYWRITE)) &#x3D;&#x3D; VM_MAYWRITE) &#123;</span><br><span class="line">		ptep_set_wrprotect(src_pte);</span><br><span class="line">		pte &#x3D; *src_pte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If it&#39;s a shared mapping, mark it clean in</span><br><span class="line">	 * the child</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (vm_flags &amp; VM_SHARED)</span><br><span class="line">		pte &#x3D; pte_mkclean(pte);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="“one-to-one”-model"><a href="#“one-to-one”-model" class="headerlink" title="“one-to-one” model"></a>“one-to-one” model</h1><p>LinuxThreads follows the so-called “one-to-one” model: each thread is actually a separate process in the kernel. The kernel scheduler takes care of scheduling the threads, just like it schedules regular processes. The threads are created with the Linux clone() system call, which is a generalization of fork() allowing the new process to share the memory space, file descriptors, and signal handlers of the parent.</p>
<p>内核线程的最大优势就是能够充分利用多处理器</p>
<h1 id="进程绑定CPU"><a href="#进程绑定CPU" class="headerlink" title="进程绑定CPU"></a>进程绑定CPU</h1><p>cpu 虚拟化，通过虚拟化，intel超线程技术，虚拟化出更多的cpu，vcpu与物理cpu不是一一对应的关系<br>两层：</p>
<ul>
<li>针对硬件芯片的虚拟化，单核4个超线程，一个核可以虚拟4个cpu出来</li>
<li>再往上走一层，虚拟cpu在vmware上也可以进程虚拟，纯软件的虚拟化，这个与cpu没有太大的关系，虚拟出来的vmware的多个cpu实际上是多个进程，并不是物理的cpu，4个处理器就是4个进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;syscall.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#define _USED_GNU</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line"></span><br><span class="line">int cpu_bind(int num) &#123;</span><br><span class="line">    pid_t self_id &#x3D; syscall(__NR_gettid);</span><br><span class="line"></span><br><span class="line">    cpu_set_t mask;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(self_id % num, &amp;mask);</span><br><span class="line"></span><br><span class="line">    sched_setaffinity(0, sizeof(mask), &amp;mask);</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int num &#x3D; sysconf(_SC_NPROCESSORS_CONF);</span><br><span class="line">    printf(&quot;cpu cores: %d\n&quot;, num);</span><br><span class="line">    pid_t pid &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">        pid &#x3D; fork();</span><br><span class="line">        &#x2F;&#x2F; 父进程 返回大于0的值，为子进程的id</span><br><span class="line">        &#x2F;&#x2F; 子进程 返回0</span><br><span class="line">        if (pid &lt;&#x3D; (pid_t)0) &#123; &#x2F;&#x2F; 是子进程，让父进程先行</span><br><span class="line">            usleep(1);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pid &gt; 0) &#123; &#x2F;&#x2F; 主进程</span><br><span class="line">        printf(&quot;running...\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         cpu_bind(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cpu_bind: <img src="/images/linux_thread/cpu_bind.png" alt="cpu_bind"><br>cpu_unbind: <img src="/images/linux_thread/cpu_unbind.png" alt="cpu_unbind"><br>绑定后的进程运行效率更高</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ul>
<li>所有线程共享主线程的虚拟地址空间(current-&gt;mm指向同一个地址)，那线程栈是共享的吗？<br>不是，调用clone的时候需要自己提供子task的栈空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 负责处理clone,fork,vfork系统调用。</span><br><span class="line"> * clone_flags-与clone的flag参数相同</span><br><span class="line"> * stack_start-与clone的child_stack相同</span><br><span class="line"> * regs-指向通用寄存器的值。是在从用户态切换到内核态时被保存到内核态堆栈中的。</span><br><span class="line"> * stack_size-未使用,总是为0</span><br><span class="line"> * parent_tidptr,child_tidptr-clone中对应参数ptid,ctid相同</span><br><span class="line"> *&#x2F;</span><br><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">          unsigned long stack_start,</span><br><span class="line">          struct pt_regs *regs,</span><br><span class="line">          unsigned long stack_size,</span><br><span class="line">          int __user *parent_tidptr,</span><br><span class="line">          int __user *child_tidptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进程 vs 线程</p>
<ul>
<li>进程是资源分配的基本单位</li>
<li>线程是调度和分配的基本单位（并发实体尽可能去共享进程的资源，比如共享一块地址空间，一个页表和一块物理内存）</li>
</ul>
</li>
</ul>
<p><img src="/images/linux_thread/thread.png" alt=""></p>
<ul>
<li><p>nginx 为什么会选择多进程绑定的方式?</p>
<ul>
<li>背景: nginx是在apache之后,apache效率低是因为对多核cpu的支持不够强,多核vs单核没有达到翻倍的效果,但是nginx做到了,在应对多核的情况下采用了“多进程”来做的,而且每一个进程都绑定了cpu,选择nginx因为支持多核</li>
</ul>
</li>
<li><p>线程 vs 协程</p>
<ul>
<li>每个线程都可以对应一个调度实体，某个线程阻塞了，其他线程还是可以工作</li>
<li>某个协程 调用read(recv)阻塞，等待， 其他协程也在等待<br><img src="/images/linux_thread/st-thread.png" alt=""></li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Kai Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://szfck.github.io/2020/06/15/Linux-thread/">https://szfck.github.io/2020/06/15/Linux-thread/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/15/Volatile/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Volatile</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/30/xss-reflect/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">xss reflect</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai Chen</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>